<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Suffix Trees and Tries</title>
<link rel="stylesheet" type="text/css" href="/study/css/syntax.css">
</head>
<body>


    <h1>Suffix Trees and Tries</h1>

    <h2>Suffix Trees</h2>

<p>Suffix trees can be used to solve <em>longest common substring</em> problems.</p>

<p>Given strings &quot;ABAB&quot; and &quot;BABA&quot;, the matrix would look like:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    |   |   | A | B | A | B |
    |   | O | O | O | O | O |
    | B | O | O | 1 | O | 1 |
    | A | O | 1 | 0 | 2 | 0 |
    | B | O | 0 | 2 | 0 | 3 |
    | A | O | 1 | 0 | 3 | 0 |
</code></pre></div>
<p>In this matrix, the 5th column tests the substring ABA of the ABAB sequence.
So cell [5, 5] compares ABA to BAB ... the lcs is BA, length 2.</p>

<p>Construct a generalized suffix tree for the strings, 
then find the deepest internal nodes which have leaf nodes from all the strings in the subtree below it.</p>

<p>A basic Suffix Tree imp.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&quot;&quot;&quot;http://goo-apple.appspot.com/article/2e8d3c6a-2c38-48b9-96c6-240b4ded253a&quot;&quot;&quot;
class Node:
        def __init__(self, start, substr):
                self.start = start
                self.substr = substr
                self.branches = {}

def insert_into_tree(subroot, suffix, start):
        prefix_len = len(subroot.substr)
        new_suffix = str(suffix[prefix_len:])
        if(len(subroot.branches) == 0):
                left_child = Node(subroot.start, &quot;&quot;)
                right_child = Node(start, new_suffix)
                subroot.branches[&quot;&quot;] = left_child
                subroot.branches[new_suffix] = right_child
        else:
                for (substr, node) in subroot.branches.items():
                        if len(substr) &gt; 0 and new_suffix.startswith(substr):
                                insert_into_tree(node, new_suffix, start)
                                break
                else:
                        new_child = Node(start, new_suffix)
                        subroot.branches[new_suffix] = new_child

def build_suffix_tree(t_str):
        len_str = len(t_str)
        i = len_str - 1
        root = Node(len_str, &quot;&quot;)
        while i &gt;= 0:
                insert_into_tree(root, str(t_str[i:]), i)
                i -= 1
        return root

def display_all_suffix(subroot, suffix_s_prefix, level = 0):
        if len(subroot.branches) == 0:
                print suffix_s_prefix, level
                return
        for (substr, node) in subroot.branches.items():
                display_all_suffix(node, suffix_s_prefix + substr, level + 1)

root = build_suffix_tree(&quot;BCABC&quot;)
display_all_suffix(root, &quot;&quot;)
</code></pre></div>
<h2><em>Tries</em> are PREFIX TREES.</h2>

<p><img src="https://hillscottc.github.io/img/suffix_tree.png" alt="suffix tree img"></p>

<p>A Simple Suffix Tree Implementation:
<script src="https://gist.github.com/hillscottc/f0460657daca55f95b62.js"></script></p>

<p>Or, here&#39;s a <a href="https://gist.github.com/hillscottc/e27f7acbc235f6a3e75d">more complete version</a>.</p>

<h3>What is a Trie?</h3>

<p><a href="http://help.topcoder.com/data-science/competing-in-algorithm-challenges/algorithm-tutorials/using-tries/">Tries on TopCoder</a></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">- The trie is a tree where each vertex represents a single word or a prefix.
- The root represents an empty string (&quot;&quot;)
- direct sons of root rep prefixes of length 1, vertexes 2 edges distant rep prefixes of length 2, etc. 
So, a vertex k edges of distance of the root has as an associated prefix of length k.
- Let v and w be two vertexes of the trie, and assume that v is a direct father of w, the\n v must have an associated prefix of w.
</code></pre></div>
<p>The tries can insert and find strings in O(L) time (where L represent the length of a single word). </p>

<p>The next figure shows a trie with the words &quot;tree&quot;, &quot;trie&quot;, &quot;algo&quot;, &quot;assoc&quot;, &quot;all&quot;, and &quot;also.&quot;</p>

<p><img src="https://hillscottc.github.io/img/trie.png" alt="trie nodes"></p>

<h3>Coding a Trie</h3>

<p>From from post on <a href="http://stackoverflow.com/questions/11015320/how-to-create-a-trie-in-python">stackoverflow</a></p>

<p><strong>Nested dictionaries</strong> ... For a large, scalable trie, nested dictionaries might become space inefficient. 
But they are the easiest approach...just a few lines.</p>

<p>Note, The method setdefault() is a get-or-create.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">In [5]: d = {}
In [6]: d.setdefault(&#39;X&#39;, {})
Out[6]: {}
In [7]: print d
{&#39;X&#39;: {}}


&gt;&gt;&gt; def make_trie(*words):
...     root = dict()
...     for word in words:
...         current_dict = root
...         for letter in word:
...             current_dict = current_dict.setdefault(letter, {})
...         current_dict = current_dict.setdefault(&#39;_end_&#39;, &#39;_end_&#39;)
...     return root
...
&gt;&gt;&gt; make_trie(&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;barz&#39;)
{&#39;b&#39;: {&#39;a&#39;: {&#39;r&#39;: {&#39;_end_&#39;: &#39;_end_&#39;, &#39;z&#39;: {&#39;_end_&#39;: &#39;_end_&#39;}},
             &#39;z&#39;: {&#39;_end_&#39;: &#39;_end_&#39;}}},
 &#39;f&#39;: {&#39;o&#39;: {&#39;o&#39;: {&#39;_end_&#39;: &#39;_end_&#39;}}}}
</code></pre></div>
<p>Then search the trie with:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&gt;&gt;&gt; def in_trie(trie, word):
...     current_dict = trie
...     for letter in word:
...         if letter in current_dict:
...             current_dict = current_dict[letter]
...         else:
...             return False
...     if _end in current_dict:
...         return True
...     else:
...         return False
... 
&gt;&gt;&gt; in_trie(make_trie(&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;barz&#39;), &#39;baz&#39;)
True
</code></pre></div>
<p>Your algorithm here is basically O(N<em>M</em>L) (where N is the length of the sentence, M is the number of words you&#39;re looking for, and L is the longest word you&#39;re looking for) for each sentence.</p>


</body>
</html>